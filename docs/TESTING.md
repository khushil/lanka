# 🧪 Testing Guide - Lanka Platform\n\nThis guide covers the comprehensive testing strategy for the Lanka platform, including unit tests, integration tests, performance tests, and quality assurance practices.\n\n## 📋 Table of Contents\n\n- [Testing Philosophy](#testing-philosophy)\n- [Test Structure](#test-structure)\n- [Testing Commands](#testing-commands)\n- [Unit Testing](#unit-testing)\n- [Integration Testing](#integration-testing)\n- [Contract Testing](#contract-testing)\n- [Performance Testing](#performance-testing)\n- [Memory Testing](#memory-testing)\n- [Security Testing](#security-testing)\n- [Coverage Requirements](#coverage-requirements)\n- [Best Practices](#best-practices)\n- [Troubleshooting](#troubleshooting)\n\n## 🎯 Testing Philosophy\n\nLanka follows a **Test-Driven Development (TDD)** approach with comprehensive test coverage across all layers:\n\n### Testing Pyramid\n```\n           /\\     E2E Tests (10%)\n          /  \\    End-to-end workflows\n         /____\\   \n        /      \\  Integration Tests (20%)\n       / System \\ API, Database, Services\n      /________\\  \n     /          \\ Unit Tests (70%)\n    / Individual \\ Functions, Classes, Modules\n   /______________\\\n```\n\n### Quality Gates\n- **Minimum Coverage**: 80% overall, 90% for core business logic\n- **Performance**: All API endpoints < 200ms (95th percentile)\n- **Memory**: Zero memory leaks in long-running tests\n- **Security**: No vulnerabilities in dependencies\n\n## 🗂️ Test Structure\n\n```\ntests/\n├── unit/                      # Unit tests\n│   ├── core/                  # Core service tests\n│   ├── modules/               # Module-specific tests\n│   └── utils/                 # Utility function tests\n├── integration/               # Integration tests\n│   ├── api/                   # API endpoint tests\n│   ├── database/              # Database integration\n│   └── realtime/              # WebSocket tests\n├── contracts/                 # API contract tests\n│   ├── graphql/               # GraphQL schema tests\n│   ├── rest/                  # REST API tests\n│   └── websocket/             # WebSocket contract tests\n├── performance/               # Performance tests\n│   ├── load/                  # Load testing scenarios\n│   └── stress/                # Stress testing scenarios\n├── memory/                    # Memory tests\n│   ├── leak-detection/        # Memory leak tests\n│   └── stability/             # Long-running stability tests\n└── fixtures/                  # Test data and mocks\n    ├── data/                  # Sample test data\n    └── mocks/                 # Mock services\n```\n\n## ⚡ Testing Commands\n\n### Basic Commands\n```bash\n# Run all tests\nnpm test\n\n# Run specific test suites\nnpm run test:unit              # Unit tests only\nnpm run test:integration       # Integration tests only\nnpm run test:contracts         # Contract tests only\nnpm run test:performance       # Performance tests only\n\n# Coverage reporting\nnpm run test:coverage          # Generate coverage report\nnpm run test:coverage:html     # HTML coverage report\n```\n\n### Specialized Testing\n```bash\n# Memory and performance testing\nnpm run test:memory-leak       # Memory leak detection\nnpm run test:memory-stability  # Long-running stability tests\nnpm run test:cache             # Cache functionality tests\n\n# Contract testing by type\nnpm run test:contracts:graphql    # GraphQL schema validation\nnpm run test:contracts:rest      # REST API contracts\nnpm run test:contracts:websocket # WebSocket contracts\nnpm run test:contracts:integration # End-to-end contracts\n```\n\n### Development Commands\n```bash\n# Watch mode for development\nnpm run test:watch             # Watch all tests\nnpm run test:unit:watch        # Watch unit tests only\n\n# Debug mode\nnpm run test:debug             # Run tests with debugger\n```\n\n## 🔬 Unit Testing\n\n### Framework: Jest + TypeScript\n\n#### Example Unit Test\n```typescript\n// tests/unit/core/services/requirement.service.test.ts\nimport { RequirementService } from '../../../../src/core/services/requirement.service';\nimport { Neo4jService } from '../../../../src/core/database/neo4j';\n\n// Mock dependencies\njest.mock('../../../../src/core/database/neo4j');\n\ndescribe('RequirementService', () => {\n  let requirementService: RequirementService;\n  let mockNeo4jService: jest.Mocked<Neo4jService>;\n\n  beforeEach(() => {\n    mockNeo4jService = Neo4jService.getInstance() as jest.Mocked<Neo4jService>;\n    requirementService = new RequirementService();\n  });\n\n  describe('createRequirement', () => {\n    it('should create a new requirement with valid data', async () => {\n      // Arrange\n      const requirementData = {\n        title: 'User Authentication',\n        description: 'Implement secure user authentication system',\n        priority: 'HIGH' as const,\n        type: 'FUNCTIONAL' as const\n      };\n\n      const expectedResult = {\n        id: 'req-123',\n        ...requirementData,\n        createdAt: expect.any(Date),\n        updatedAt: expect.any(Date)\n      };\n\n      mockNeo4jService.executeQuery.mockResolvedValue({\n        records: [{ get: jest.fn().mockReturnValue(expectedResult) }]\n      });\n\n      // Act\n      const result = await requirementService.createRequirement(requirementData);\n\n      // Assert\n      expect(result).toEqual(expectedResult);\n      expect(mockNeo4jService.executeQuery).toHaveBeenCalledWith(\n        expect.stringContaining('CREATE'),\n        expect.objectContaining(requirementData)\n      );\n    });\n\n    it('should throw error for invalid requirement data', async () => {\n      // Arrange\n      const invalidData = {\n        title: '', // Invalid: empty title\n        priority: 'INVALID' as any\n      };\n\n      // Act & Assert\n      await expect(\n        requirementService.createRequirement(invalidData)\n      ).rejects.toThrow('Invalid requirement data');\n    });\n  });\n});\n```\n\n### Testing Patterns\n\n#### 1. Service Layer Testing\n```typescript\n// Test business logic in isolation\ndescribe('ArchitectureService', () => {\n  it('should generate architecture recommendations', async () => {\n    // Test AI-powered architecture generation\n  });\n});\n```\n\n#### 2. Utility Function Testing\n```typescript\n// Test pure functions\ndescribe('dateUtils', () => {\n  it('should format ISO date correctly', () => {\n    const input = new Date('2024-01-15T10:30:00Z');\n    const result = formatISODate(input);\n    expect(result).toBe('2024-01-15T10:30:00.000Z');\n  });\n});\n```\n\n## 🔗 Integration Testing\n\n### Database Integration Tests\n```typescript\n// tests/integration/database/neo4j.integration.test.ts\ndescribe('Neo4j Database Integration', () => {\n  beforeAll(async () => {\n    // Setup test database\n    await Neo4jService.getInstance().initializeSchema();\n  });\n\n  afterEach(async () => {\n    // Clean up test data\n    await Neo4jService.getInstance().executeQuery(\n      'MATCH (n) WHERE n.id STARTS WITH \"test-\" DETACH DELETE n'\n    );\n  });\n\n  it('should create and retrieve requirements', async () => {\n    // Test full database workflow\n  });\n});\n```\n\n### API Integration Tests\n```typescript\n// tests/integration/api/graphql.integration.test.ts\nimport request from 'supertest';\nimport { app } from '../../../src/index';\n\ndescribe('GraphQL API Integration', () => {\n  it('should create requirement via GraphQL', async () => {\n    const mutation = `\n      mutation CreateRequirement($input: CreateRequirementInput!) {\n        createRequirement(input: $input) {\n          id\n          title\n          status\n        }\n      }\n    `;\n\n    const response = await request(app)\n      .post('/graphql')\n      .send({\n        query: mutation,\n        variables: {\n          input: {\n            title: 'Test Requirement',\n            description: 'Test Description'\n          }\n        }\n      })\n      .expect(200);\n\n    expect(response.body.data.createRequirement).toMatchObject({\n      id: expect.any(String),\n      title: 'Test Requirement'\n    });\n  });\n});\n```\n\n## 📜 Contract Testing\n\n### GraphQL Schema Validation\n```typescript\n// tests/contracts/graphql/schema.contract.test.ts\nimport { buildSchema, validate } from 'graphql';\nimport { createGraphQLSchema } from '../../../src/api/graphql/schema';\n\ndescribe('GraphQL Schema Contracts', () => {\n  let schema: GraphQLSchema;\n\n  beforeAll(async () => {\n    schema = await createGraphQLSchema();\n  });\n\n  it('should have valid schema structure', () => {\n    expect(schema).toBeDefined();\n    expect(schema.getQueryType()).toBeDefined();\n    expect(schema.getMutationType()).toBeDefined();\n  });\n\n  it('should support required queries', async () => {\n    const query = `\n      query TestQuery {\n        requirements {\n          id\n          title\n        }\n      }\n    `;\n\n    const errors = validate(schema, parse(query));\n    expect(errors).toHaveLength(0);\n  });\n});\n```\n\n## ⚡ Performance Testing\n\n### Load Testing with Artillery\n```yaml\n# tests/performance/load-test.yml\nconfig:\n  target: 'http://localhost:4000'\n  phases:\n    - duration: 60\n      arrivalRate: 10\n      name: \"Warm up\"\n    - duration: 120\n      arrivalRate: 50\n      name: \"Load test\"\n    - duration: 60\n      arrivalRate: 100\n      name: \"Spike test\"\n  variables:\n    testData:\n      - title: \"Performance Test Requirement 1\"\n      - title: \"Performance Test Requirement 2\"\n\nscenarios:\n  - name: \"Create and fetch requirements\"\n    weight: 70\n    flow:\n      - post:\n          url: \"/graphql\"\n          json:\n            query: |\n              mutation {\n                createRequirement(input: {\n                  title: \"{{ title }}\"\n                  description: \"Performance test requirement\"\n                }) {\n                  id\n                }\n              }\n          capture:\n            - json: \"$.data.createRequirement.id\"\n              as: \"requirementId\"\n      - post:\n          url: \"/graphql\"\n          json:\n            query: |\n              query {\n                requirement(id: \"{{ requirementId }}\") {\n                  id\n                  title\n                  description\n                }\n              }\n```\n\n### Performance Test Implementation\n```typescript\n// tests/performance/api-performance.test.ts\ndescribe('API Performance Tests', () => {\n  it('should handle 1000 concurrent requests', async () => {\n    const promises = Array.from({ length: 1000 }, async (_, i) => {\n      const start = Date.now();\n      const response = await request(app)\n        .post('/graphql')\n        .send({\n          query: 'query { health }'\n        });\n      const duration = Date.now() - start;\n      \n      return { response, duration };\n    });\n\n    const results = await Promise.all(promises);\n    \n    // Assert response times\n    const durations = results.map(r => r.duration);\n    const p95 = durations.sort()[Math.floor(durations.length * 0.95)];\n    \n    expect(p95).toBeLessThan(200); // 95th percentile under 200ms\n    \n    // Assert all requests succeeded\n    results.forEach(({ response }) => {\n      expect(response.status).toBe(200);\n    });\n  });\n});\n```\n\n## 🧠 Memory Testing\n\n### Memory Leak Detection\n```typescript\n// tests/memory/memory-leak.test.ts\ndescribe('Memory Leak Detection', () => {\n  it('should not leak memory during heavy operations', async () => {\n    const initialMemory = process.memoryUsage().heapUsed;\n    \n    // Perform memory-intensive operations\n    for (let i = 0; i < 1000; i++) {\n      await performHeavyOperation();\n    }\n    \n    // Force garbage collection\n    if (global.gc) {\n      global.gc();\n      global.gc();\n    }\n    \n    const finalMemory = process.memoryUsage().heapUsed;\n    const memoryIncrease = finalMemory - initialMemory;\n    const memoryIncreasePercent = (memoryIncrease / initialMemory) * 100;\n    \n    // Memory increase should be minimal (less than 10%)\n    expect(memoryIncreasePercent).toBeLessThan(10);\n  });\n});\n```\n\n## 🛡️ Security Testing\n\n### Input Validation Tests\n```typescript\ndescribe('Security Tests', () => {\n  it('should prevent SQL injection', async () => {\n    const maliciousInput = \"'; DROP TABLE requirements; --\";\n    \n    await expect(\n      requirementService.searchRequirements(maliciousInput)\n    ).not.toThrow();\n  });\n\n  it('should sanitize XSS attempts', async () => {\n    const xssPayload = '<script>alert(\"xss\")</script>';\n    \n    const result = await requirementService.createRequirement({\n      title: xssPayload,\n      description: 'Test'\n    });\n    \n    expect(result.title).not.toContain('<script>');\n  });\n});\n```\n\n## 📊 Coverage Requirements\n\n### Coverage Targets\n| Component | Target | Notes |\n|-----------|--------|-------|\n| **Overall** | 80% | Minimum acceptable coverage |\n| **Core Services** | 90% | Business logic must be well tested |\n| **API Endpoints** | 95% | All API paths covered |\n| **Utility Functions** | 95% | Pure functions easy to test |\n| **Database Layer** | 85% | Integration test coverage |\n\n### Coverage Configuration\n```javascript\n// jest.config.js\nmodule.exports = {\n  coverageThreshold: {\n    global: {\n      branches: 80,\n      functions: 80,\n      lines: 80,\n      statements: 80\n    },\n    './src/core/services/': {\n      branches: 90,\n      functions: 90,\n      lines: 90,\n      statements: 90\n    }\n  },\n  coverageReporters: [\n    'text',\n    'text-summary',\n    'html',\n    'lcov',\n    'json-summary'\n  ]\n};\n```\n\n## 🏆 Best Practices\n\n### 1. Test Organization\n- **One test file per source file**\n- **Group related tests with `describe`**\n- **Use clear, descriptive test names**\n- **Follow AAA pattern: Arrange, Act, Assert**\n\n### 2. Test Data Management\n```typescript\n// Use factory functions for test data\nconst createTestRequirement = (overrides = {}) => ({\n  title: 'Test Requirement',\n  description: 'Test Description',\n  priority: 'MEDIUM',\n  type: 'FUNCTIONAL',\n  ...overrides\n});\n```\n\n### 3. Mock Management\n```typescript\n// Create reusable mocks\nconst mockNeo4jService = {\n  executeQuery: jest.fn(),\n  close: jest.fn()\n};\n\n// Reset mocks between tests\nbeforeEach(() => {\n  jest.clearAllMocks();\n});\n```\n\n### 4. Async Testing\n```typescript\n// Always use async/await for async tests\nit('should handle async operations', async () => {\n  await expect(asyncFunction()).resolves.toBe(expectedValue);\n});\n```\n\n### 5. Error Testing\n```typescript\n// Test error conditions\nit('should throw appropriate error', async () => {\n  await expect(\n    service.method(invalidInput)\n  ).rejects.toThrow('Expected error message');\n});\n```\n\n## 🔧 Troubleshooting\n\n### Common Issues\n\n#### 1. Test Timeouts\n```bash\n# Increase timeout for slow tests\nnpm test -- --testTimeout=30000\n```\n\n#### 2. Memory Issues\n```bash\n# Run tests with more memory\nnode --max-old-space-size=8192 node_modules/.bin/jest\n```\n\n#### 3. Database Connection Issues\n```typescript\n// Ensure proper cleanup\nafterAll(async () => {\n  await Neo4jService.getInstance().close();\n});\n```\n\n#### 4. Port Conflicts\n```javascript\n// Use random ports for integration tests\nconst PORT = process.env.TEST_PORT || 0; // 0 = random available port\n```\n\n### Debugging Tests\n\n#### 1. Debug Mode\n```bash\nnpm run test:debug\n# Then attach debugger to Node process\n```\n\n#### 2. Isolated Test Running\n```bash\n# Run specific test file\nnpm test -- tests/unit/core/services/requirement.service.test.ts\n\n# Run specific test case\nnpm test -- --testNamePattern=\"should create requirement\"\n```\n\n#### 3. Verbose Output\n```bash\nnpm test -- --verbose\n```\n\n## 📈 Continuous Testing\n\n### GitHub Actions Integration\n```yaml\n# .github/workflows/test.yml\nname: Tests\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '18'\n          cache: 'npm'\n      - run: npm ci\n      - run: npm run test:coverage\n      - uses: codecov/codecov-action@v3\n        with:\n          file: ./coverage/lcov.info\n```\n\n### Quality Gates\n- All tests must pass before merge\n- Coverage must not decrease\n- No high-severity security vulnerabilities\n- Performance tests must pass benchmarks\n\n---\n\n## 📚 Related Documentation\n\n- [Development Guide](DEVELOPMENT.md)\n- [API Documentation](API.md)\n- [Deployment Guide](DEPLOYMENT.md)\n- [Architecture Overview](ARCHITECTURE.md)\n\n---\n\n**Happy Testing! 🚀**\n\n*Remember: Good tests are not just about coverage numbers—they're about confidence in your code and documentation of expected behavior.*