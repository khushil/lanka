export declare const architectureTypeDefs = "\n  enum ArchitectureDecisionStatus {\n    DRAFT\n    PROPOSED\n    APPROVED\n    IMPLEMENTED\n    DEPRECATED\n    SUPERSEDED\n  }\n\n  enum ArchitecturePatternType {\n    MICROSERVICES\n    MONOLITHIC\n    SERVERLESS\n    EVENT_DRIVEN\n    LAYERED\n    HEXAGONAL\n    CQRS\n    SAGA\n  }\n\n  enum CloudProvider {\n    AWS\n    AZURE\n    GCP\n    ONPREMISES\n    HYBRID\n  }\n\n  enum RequirementMappingType {\n    DIRECT\n    DERIVED\n    INFLUENCED\n    CONSTRAINT\n    QUALITY_ATTRIBUTE\n  }\n\n  enum AlignmentType {\n    FULLY_ALIGNED\n    PARTIALLY_ALIGNED\n    MISALIGNED\n    NOT_APPLICABLE\n  }\n\n  enum ValidationStatus {\n    PENDING\n    VALIDATED\n    NEEDS_REVIEW\n    REJECTED\n  }\n\n  type ArchitectureDecision {\n    id: ID!\n    title: String!\n    description: String!\n    rationale: String!\n    status: ArchitectureDecisionStatus!\n    alternatives: [Alternative!]!\n    consequences: [String!]!\n    tradeOffs: [TradeOff!]!\n    createdAt: Date!\n    updatedAt: Date\n    approvedAt: Date\n    deprecatedAt: Date\n    project: Project\n    requirements: [Requirement!]!\n    patterns: [ArchitecturePattern!]\n    technologyStack: TechnologyStack\n    mappings: [RequirementArchitectureMapping!]!\n    alignments: [ArchitectureRequirementAlignment!]!\n  }\n\n  type Alternative {\n    title: String!\n    description: String!\n    pros: [String!]!\n    cons: [String!]!\n    rejectionReason: String\n  }\n\n  type TradeOff {\n    aspect: String!\n    gain: String!\n    loss: String!\n    mitigation: String\n  }\n\n  type ArchitecturePattern {\n    id: ID!\n    name: String!\n    type: ArchitecturePatternType!\n    description: String!\n    applicabilityConditions: [String!]!\n    components: [PatternComponent!]!\n    qualityAttributes: [QualityAttribute!]!\n    knownUses: [String!]!\n    successRate: Float!\n    adoptionCount: Int!\n    createdAt: Date!\n    updatedAt: Date\n    decisions: [ArchitectureDecision!]!\n    recommendations: [PatternRecommendation!]!\n  }\n\n  type PatternComponent {\n    name: String!\n    responsibility: String!\n    interactions: [String!]!\n    constraints: [String!]\n  }\n\n  type QualityAttribute {\n    name: String!\n    impact: String!\n    description: String!\n    metric: String\n  }\n\n  type TechnologyStack {\n    id: ID!\n    name: String!\n    description: String!\n    layers: [TechnologyLayer!]!\n    compatibility: CompatibilityMatrix!\n    performanceMetrics: PerformanceMetrics!\n    costEstimate: CostEstimate!\n    teamExpertise: Float\n    successRate: Float\n    createdAt: Date!\n    updatedAt: Date\n    decisions: [ArchitectureDecision!]!\n    recommendations: [TechnologyRecommendation!]!\n  }\n\n  type TechnologyLayer {\n    name: String!\n    technologies: [Technology!]!\n    purpose: String!\n    alternatives: [Technology!]\n  }\n\n  type Technology {\n    name: String!\n    version: String!\n    license: String!\n    vendor: String\n    maturity: String!\n    communitySupport: Float!\n    learningCurve: String!\n  }\n\n  type CompatibilityMatrix {\n    compatible: [[String!]!]!\n    incompatible: [[String!]!]!\n    requires: JSON!\n  }\n\n  type PerformanceMetrics {\n    throughput: Float\n    latency: Float\n    scalability: String\n    reliability: Float\n    maintainability: Float\n  }\n\n  type CostEstimate {\n    upfront: Float!\n    monthly: Float!\n    yearly: Float!\n    currency: String!\n    breakdown: [CostBreakdown!]!\n  }\n\n  type CostBreakdown {\n    category: String!\n    service: String!\n    quantity: Float!\n    unitCost: Float!\n    totalCost: Float!\n  }\n\n  type CloudConfiguration {\n    provider: CloudProvider!\n    services: [CloudService!]!\n    regions: [String!]!\n    availability: String!\n    compliance: [String!]!\n    costOptimizations: [OptimizationStrategy!]!\n  }\n\n  type CloudService {\n    name: String!\n    type: String!\n    configuration: JSON!\n    estimatedCost: Float!\n    alternativeServices: [String!]\n  }\n\n  type OptimizationStrategy {\n    name: String!\n    description: String!\n    potentialSavings: Float!\n    implementation: String!\n    tradeOffs: [String!]\n  }\n\n  # Integration Types\n\n  type RequirementArchitectureMapping {\n    id: ID!\n    requirement: Requirement!\n    architectureDecision: ArchitectureDecision\n    architecturePattern: ArchitecturePattern\n    technologyStack: TechnologyStack\n    mappingType: RequirementMappingType!\n    confidence: Float!\n    rationale: String!\n    implementationGuidance: String\n    tradeOffs: [ArchitecturalTradeOff!]\n    createdAt: Date!\n    updatedAt: Date\n    validatedAt: Date\n    validatedBy: String\n  }\n\n  type ArchitecturalTradeOff {\n    aspect: String!\n    benefit: String!\n    cost: String!\n    riskLevel: String!\n    mitigationStrategy: String\n  }\n\n  type RequirementArchitectureRecommendation {\n    id: ID!\n    requirement: Requirement!\n    recommendedPatterns: [PatternRecommendation!]!\n    recommendedTechnologies: [TechnologyRecommendation!]!\n    architecturalConstraints: [ArchitecturalConstraint!]!\n    qualityAttributes: [QualityAttributeMapping!]!\n    implementationStrategy: ImplementationStrategy!\n    confidence: Float!\n    reasoning: [String!]!\n    alternativeApproaches: [AlternativeApproach!]\n    createdAt: Date!\n    updatedAt: Date\n  }\n\n  type PatternRecommendation {\n    pattern: ArchitecturePattern!\n    applicabilityScore: Float!\n    benefits: [String!]!\n    risks: [String!]!\n    implementationComplexity: String!\n    prerequisites: [String!]!\n  }\n\n  type TechnologyRecommendation {\n    technologyStack: TechnologyStack!\n    suitabilityScore: Float!\n    alignmentReason: String!\n    implementationEffort: Float!\n    learningCurveImpact: String!\n    riskFactors: [String!]!\n  }\n\n  type ArchitecturalConstraint {\n    type: String!\n    description: String!\n    impact: String!\n    mandatory: Boolean!\n    validationCriteria: [String!]\n  }\n\n  type QualityAttributeMapping {\n    requirement: Requirement!\n    qualityAttribute: String!\n    targetValue: String\n    measurementCriteria: String!\n    architecturalImplication: String!\n    verificationMethod: String!\n  }\n\n  type ImplementationStrategy {\n    approach: String!\n    phases: [ImplementationPhase!]\n    dependencies: [String!]!\n    riskMitigations: [String!]!\n    estimatedEffort: Float!\n    timeline: String!\n  }\n\n  type ImplementationPhase {\n    name: String!\n    description: String!\n    requirements: [Requirement!]!\n    architectureComponents: [String!]!\n    dependencies: [String!]!\n    deliverables: [String!]!\n    estimatedDuration: Float!\n  }\n\n  type AlternativeApproach {\n    name: String!\n    description: String!\n    patterns: [String!]!\n    technologies: [String!]!\n    pros: [String!]!\n    cons: [String!]!\n    suitabilityConditions: [String!]!\n  }\n\n  type ArchitectureRequirementAlignment {\n    id: ID!\n    requirement: Requirement!\n    architectureDecision: ArchitectureDecision!\n    alignmentScore: Float!\n    alignmentType: AlignmentType!\n    gaps: [String!]!\n    recommendations: [String!]!\n    validationStatus: ValidationStatus!\n    lastAssessed: Date!\n    assessedBy: String\n  }\n\n  type RequirementImpactAnalysis {\n    id: ID!\n    requirement: Requirement!\n    impactedArchitectureDecisions: [ArchitectureDecision!]!\n    impactedPatterns: [ArchitecturePattern!]!\n    impactedTechnologies: [TechnologyStack!]!\n    cascadingChanges: [CascadingChange!]!\n    riskAssessment: RiskAssessment!\n    changeComplexity: String!\n    estimatedEffort: Float!\n    createdAt: Date!\n  }\n\n  type CascadingChange {\n    targetType: String!\n    targetId: String!\n    changeType: String!\n    reason: String!\n    priority: String!\n  }\n\n  type RiskAssessment {\n    overallRisk: String!\n    riskFactors: [RiskFactor!]!\n    mitigationStrategies: [String!]!\n    contingencyPlan: String\n  }\n\n  type RiskFactor {\n    category: String!\n    description: String!\n    probability: Float!\n    impact: Float!\n    score: Float!\n  }\n\n  type IntegrationMetrics {\n    totalRequirements: Int!\n    mappedRequirements: Int!\n    unmappedRequirements: Int!\n    averageConfidence: Float!\n    alignmentDistribution: JSON!\n    validationCoverage: Float!\n    recommendationAccuracy: Float!\n    implementationProgress: Float!\n  }\n\n  type IntegrationHealthCheck {\n    status: String!\n    lastChecked: Date!\n    issues: [HealthIssue!]!\n    metrics: IntegrationMetrics!\n    recommendations: [String!]!\n  }\n\n  type HealthIssue {\n    type: String!\n    description: String!\n    severity: String!\n    affectedItems: [String!]!\n    suggestedActions: [String!]!\n  }\n\n  # Input Types\n\n  input CreateArchitectureDecisionInput {\n    title: String!\n    description: String!\n    rationale: String!\n    requirementIds: [ID!]!\n    patternIds: [ID!]\n    technologyStackId: ID\n    alternatives: [AlternativeInput!]\n    consequences: [String!]\n    tradeOffs: [TradeOffInput!]\n  }\n\n  input AlternativeInput {\n    title: String!\n    description: String!\n    pros: [String!]!\n    cons: [String!]!\n    rejectionReason: String\n  }\n\n  input TradeOffInput {\n    aspect: String!\n    gain: String!\n    loss: String!\n    mitigation: String\n  }\n\n  input UpdateArchitectureDecisionInput {\n    title: String\n    description: String\n    rationale: String\n    status: ArchitectureDecisionStatus\n    alternatives: [AlternativeInput!]\n    consequences: [String!]\n    tradeOffs: [TradeOffInput!]\n  }\n\n  input CreateArchitecturePatternInput {\n    name: String!\n    type: ArchitecturePatternType!\n    description: String!\n    applicabilityConditions: [String!]!\n    components: [PatternComponentInput!]!\n    qualityAttributes: [QualityAttributeInput!]!\n    knownUses: [String!]!\n  }\n\n  input PatternComponentInput {\n    name: String!\n    responsibility: String!\n    interactions: [String!]!\n    constraints: [String!]\n  }\n\n  input QualityAttributeInput {\n    name: String!\n    impact: String!\n    description: String!\n    metric: String\n  }\n\n  input CreateTechnologyStackInput {\n    name: String!\n    description: String!\n    layers: [TechnologyLayerInput!]!\n    teamExpertise: Float\n  }\n\n  input TechnologyLayerInput {\n    name: String!\n    technologies: [TechnologyInput!]!\n    purpose: String!\n    alternatives: [TechnologyInput!]\n  }\n\n  input TechnologyInput {\n    name: String!\n    version: String!\n    license: String!\n    vendor: String\n    maturity: String!\n    communitySupport: Float!\n    learningCurve: String!\n  }\n\n  input CreateMappingInput {\n    requirementId: ID!\n    architectureDecisionId: ID\n    architecturePatternId: ID\n    technologyStackId: ID\n    mappingType: RequirementMappingType!\n    confidence: Float!\n    rationale: String!\n    implementationGuidance: String\n  }\n\n  input CrossModuleFiltersInput {\n    projectId: ID\n    requirementTypes: [RequirementType!]\n    architectureDecisionStatus: [ArchitectureDecisionStatus!]\n    dateRange: DateRangeInput\n    confidenceThreshold: Float\n    alignmentScore: ScoreRangeInput\n  }\n\n  input DateRangeInput {\n    start: Date!\n    end: Date!\n  }\n\n  input ScoreRangeInput {\n    min: Float!\n    max: Float!\n  }\n\n  # Extended Queries and Mutations\n\n  extend type Query {\n    # Architecture Decision Queries\n    architectureDecision(id: ID!): ArchitectureDecision\n    architectureDecisions(\n      projectId: ID\n      status: ArchitectureDecisionStatus\n      requirementId: ID\n      limit: Int = 20\n      offset: Int = 0\n    ): [ArchitectureDecision!]!\n\n    # Architecture Pattern Queries\n    architecturePattern(id: ID!): ArchitecturePattern\n    architecturePatterns(\n      type: ArchitecturePatternType\n      applicabilityConditions: [String!]\n      limit: Int = 20\n      offset: Int = 0\n    ): [ArchitecturePattern!]!\n\n    # Technology Stack Queries\n    technologyStack(id: ID!): TechnologyStack\n    technologyStacks(\n      teamExpertise: Float\n      performanceRequirements: String\n      limit: Int = 20\n      offset: Int = 0\n    ): [TechnologyStack!]!\n\n    # Integration Queries\n    requirementArchitectureMappings(\n      requirementId: ID\n      architectureDecisionId: ID\n      confidence: Float\n      limit: Int = 20\n      offset: Int = 0\n    ): [RequirementArchitectureMapping!]!\n\n    generateArchitectureRecommendations(\n      requirementId: ID!\n    ): RequirementArchitectureRecommendation!\n\n    validateRequirementAlignment(\n      requirementId: ID!\n      architectureDecisionId: ID!\n    ): ArchitectureRequirementAlignment!\n\n    analyzeRequirementImpact(\n      requirementId: ID!\n    ): RequirementImpactAnalysis!\n\n    getIntegrationMetrics(\n      projectId: ID\n    ): IntegrationMetrics!\n\n    performIntegrationHealthCheck: IntegrationHealthCheck!\n\n    # Cross-Module Search\n    searchArchitectureByRequirement(\n      requirementId: ID!\n      includePatterns: Boolean = true\n      includeTechnologies: Boolean = true\n    ): [ArchitectureDecision!]!\n\n    searchRequirementsByArchitecture(\n      architectureDecisionId: ID!\n      includeRelated: Boolean = true\n    ): [Requirement!]!\n\n    # Pattern and Technology Recommendations\n    recommendPatterns(\n      requirementIds: [ID!]!\n      constraints: [String!]\n    ): [PatternRecommendation!]!\n\n    recommendTechnologies(\n      requirementIds: [ID!]!\n      patternIds: [ID!]\n      constraints: [String!]\n    ): [TechnologyRecommendation!]!\n  }\n\n  extend type Mutation {\n    # Architecture Decision Mutations\n    createArchitectureDecision(\n      input: CreateArchitectureDecisionInput!\n    ): ArchitectureDecision!\n\n    updateArchitectureDecision(\n      id: ID!\n      input: UpdateArchitectureDecisionInput!\n    ): ArchitectureDecision!\n\n    approveArchitectureDecision(id: ID!): ArchitectureDecision!\n\n    deprecateArchitectureDecision(\n      id: ID!\n      reason: String!\n      replacementId: ID\n    ): ArchitectureDecision!\n\n    # Architecture Pattern Mutations\n    createArchitecturePattern(\n      input: CreateArchitecturePatternInput!\n    ): ArchitecturePattern!\n\n    updateArchitecturePattern(\n      id: ID!\n      input: CreateArchitecturePatternInput!\n    ): ArchitecturePattern!\n\n    # Technology Stack Mutations\n    createTechnologyStack(\n      input: CreateTechnologyStackInput!\n    ): TechnologyStack!\n\n    updateTechnologyStack(\n      id: ID!\n      input: CreateTechnologyStackInput!\n    ): TechnologyStack!\n\n    # Integration Mutations\n    createRequirementArchitectureMapping(\n      input: CreateMappingInput!\n    ): RequirementArchitectureMapping!\n\n    updateMappingConfidence(\n      id: ID!\n      confidence: Float!\n      rationale: String\n    ): RequirementArchitectureMapping!\n\n    validateMapping(\n      id: ID!\n      validated: Boolean!\n      validatorId: ID!\n      notes: String\n    ): RequirementArchitectureMapping!\n\n    # Batch Operations\n    batchCreateMappings(\n      mappings: [CreateMappingInput!]!\n    ): [RequirementArchitectureMapping!]!\n\n    batchValidateAlignments(\n      alignments: [ID!]!\n      validatorId: ID!\n    ): [ArchitectureRequirementAlignment!]!\n\n    # Optimization Operations\n    optimizeArchitectureForRequirements(\n      requirementIds: [ID!]!\n      constraints: [String!]\n    ): RequirementArchitectureRecommendation!\n\n    rebalanceArchitectureDecisions(\n      projectId: ID!\n      strategy: String = \"BALANCED\"\n    ): [ArchitectureDecision!]!\n\n    # Data Migration and Cleanup\n    migrateExistingMappings(\n      projectId: ID!\n      dryRun: Boolean = true\n    ): [RequirementArchitectureMapping!]!\n\n    cleanupBrokenMappings(\n      projectId: ID\n    ): Int!\n  }\n\n  # Subscriptions for real-time updates\n  extend type Subscription {\n    architectureDecisionCreated(projectId: ID!): ArchitectureDecision!\n    architectureDecisionUpdated(projectId: ID!): ArchitectureDecision!\n    mappingCreated(requirementId: ID): RequirementArchitectureMapping!\n    mappingValidated(requirementId: ID): RequirementArchitectureMapping!\n    recommendationGenerated(requirementId: ID!): RequirementArchitectureRecommendation!\n    integrationHealthUpdated: IntegrationHealthCheck!\n  }\n";
//# sourceMappingURL=architecture.schema.d.ts.map