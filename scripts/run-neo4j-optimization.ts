#!/usr/bin/env tsx\n\nimport { Neo4jService } from '../src/core/database/neo4j';\nimport { performanceValidator } from '../src/database/validation/performance-validator';\nimport { queryResultCache } from '../src/database/cache/query-result-cache';\nimport { slowQueryProfiler } from '../src/database/optimization/slow-query-profiler';\nimport { queryPerformanceMonitor } from '../src/database/monitoring/query-performance-monitor';\nimport { logger } from '../src/core/logging/logger';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\n/**\n * LANKA Neo4j Performance Optimization Runner - Phase 2.3\n * \n * This script executes the comprehensive Neo4j optimization pipeline:\n * 1. Runs database migration with missing indexes\n * 2. Validates performance improvements\n * 3. Generates optimization report\n * 4. Verifies success criteria\n */\n\ninterface OptimizationReport {\n  timestamp: string;\n  phase: string;\n  preOptimizationMetrics: any;\n  postOptimizationMetrics: any;\n  appliedOptimizations: string[];\n  performanceImprovements: any;\n  successCriteria: {\n    allQueriesUnder100ms: boolean;\n    indexesProperlyUtilized: boolean;\n    queryPlansOptimized: boolean;\n    noFullGraphScansDetected: boolean;\n  };\n  recommendations: string[];\n  overallSuccess: boolean;\n}\n\nclass Neo4jOptimizationRunner {\n  private neo4jService: Neo4jService;\n  private report: OptimizationReport;\n\n  constructor() {\n    this.neo4jService = Neo4jService.getInstance();\n    this.report = {\n      timestamp: new Date().toISOString(),\n      phase: 'Phase 2.3 - Neo4j Query Optimization',\n      preOptimizationMetrics: {},\n      postOptimizationMetrics: {},\n      appliedOptimizations: [],\n      performanceImprovements: {},\n      successCriteria: {\n        allQueriesUnder100ms: false,\n        indexesProperlyUtilized: false,\n        queryPlansOptimized: false,\n        noFullGraphScansDetected: false\n      },\n      recommendations: [],\n      overallSuccess: false\n    };\n  }\n\n  /**\n   * Run the complete optimization pipeline\n   */\n  public async runOptimization(): Promise<OptimizationReport> {\n    logger.info('üöÄ Starting LANKA Neo4j Performance Optimization - Phase 2.3');\n\n    try {\n      // Step 1: Collect pre-optimization baseline metrics\n      logger.info('üìä Step 1: Collecting baseline performance metrics...');\n      await this.collectBaselineMetrics();\n\n      // Step 2: Apply database migrations (indexes)\n      logger.info('üîß Step 2: Applying database migrations and indexes...');\n      await this.applyDatabaseMigrations();\n\n      // Step 3: Apply APOC procedures\n      logger.info('‚ö° Step 3: Installing APOC optimization procedures...');\n      await this.applyAPOCProcedures();\n\n      // Step 4: Configure query result caching\n      logger.info('üíæ Step 4: Configuring query result caching...');\n      await this.configureCaching();\n\n      // Step 5: Run performance validation\n      logger.info('‚úÖ Step 5: Running performance validation tests...');\n      await this.runPerformanceValidation();\n\n      // Step 6: Collect post-optimization metrics\n      logger.info('üìà Step 6: Collecting post-optimization metrics...');\n      await this.collectPostOptimizationMetrics();\n\n      // Step 7: Verify success criteria\n      logger.info('üéØ Step 7: Verifying optimization success criteria...');\n      await this.verifySuccessCriteria();\n\n      // Step 8: Generate final report\n      logger.info('üìã Step 8: Generating optimization report...');\n      await this.generateReport();\n\n      logger.info('‚ú® Neo4j optimization completed successfully!');\n      return this.report;\n\n    } catch (error) {\n      logger.error('‚ùå Neo4j optimization failed', error);\n      this.report.overallSuccess = false;\n      this.report.recommendations.push(`Optimization failed: ${error}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Collect baseline performance metrics before optimization\n   */\n  private async collectBaselineMetrics(): Promise<void> {\n    const { benchmarkResults, performanceBaseline } = await performanceValidator.runPerformanceBenchmarks();\n    \n    this.report.preOptimizationMetrics = {\n      benchmarks: benchmarkResults,\n      baseline: performanceBaseline,\n      timestamp: new Date().toISOString()\n    };\n\n    logger.info('üìä Baseline metrics collected', {\n      queries: benchmarkResults.length,\n      averageTime: performanceBaseline.maxQueryTime\n    });\n  }\n\n  /**\n   * Apply database migrations including indexes\n   */\n  private async applyDatabaseMigrations(): Promise<void> {\n    const migrationScript = path.join(__dirname, '../src/database/migrations/001-add-missing-indexes.cypher');\n    \n    if (!fs.existsSync(migrationScript)) {\n      throw new Error(`Migration script not found: ${migrationScript}`);\n    }\n\n    const migrationCypher = fs.readFileSync(migrationScript, 'utf-8');\n    const statements = migrationCypher\n      .split(';')\n      .map(stmt => stmt.trim())\n      .filter(stmt => stmt && !stmt.startsWith('//') && !stmt.startsWith('/*'));\n\n    const appliedMigrations = [];\n\n    for (const statement of statements) {\n      if (statement.toUpperCase().includes('CREATE INDEX') || \n          statement.toUpperCase().includes('CREATE VECTOR INDEX') ||\n          statement.toUpperCase().includes('CREATE RANGE INDEX') ||\n          statement.toUpperCase().includes('CREATE FULLTEXT INDEX')) {\n        \n        try {\n          await this.neo4jService.executeQuery(statement);\n          appliedMigrations.push(statement.split(' ')[2] || 'unnamed_index');\n          logger.debug(`‚úÖ Applied migration: ${statement.substring(0, 100)}...`);\n        } catch (error: any) {\n          if (error.message.includes('already exists')) {\n            logger.debug(`‚ö†Ô∏è  Index already exists: ${statement.substring(0, 50)}...`);\n          } else {\n            logger.error(`‚ùå Failed to apply migration: ${statement}`, error);\n            throw error;\n          }\n        }\n      }\n    }\n\n    this.report.appliedOptimizations.push(...appliedMigrations.map(idx => `Index: ${idx}`));\n    logger.info(`üîß Applied ${appliedMigrations.length} database indexes`);\n  }\n\n  /**\n   * Apply APOC procedures for advanced optimization\n   */\n  private async applyAPOCProcedures(): Promise<void> {\n    const apocScript = path.join(__dirname, '../src/database/apoc/similarity-procedures.cypher');\n    \n    if (!fs.existsSync(apocScript)) {\n      logger.warn('‚ö†Ô∏è  APOC procedures script not found, skipping...');\n      return;\n    }\n\n    try {\n      // Check if APOC is available\n      await this.neo4jService.executeQuery('CALL apoc.version() YIELD version RETURN version');\n      \n      const apocCypher = fs.readFileSync(apocScript, 'utf-8');\n      \n      // Extract procedure definitions (simplified extraction)\n      const procedureMatches = apocCypher.match(/CALL apoc\\.custom\\.asProcedure\\([^;]+;/g);\n      \n      if (procedureMatches) {\n        for (const procedureCall of procedureMatches) {\n          try {\n            await this.neo4jService.executeQuery(procedureCall);\n            this.report.appliedOptimizations.push('APOC Custom Procedure');\n            logger.debug('‚úÖ Applied APOC procedure');\n          } catch (error: any) {\n            logger.warn('‚ö†Ô∏è  Failed to apply APOC procedure', { error: error.message });\n          }\n        }\n      }\n\n      logger.info('‚ö° APOC procedures configured');\n      \n    } catch (error) {\n      logger.warn('‚ö†Ô∏è  APOC not available, skipping advanced procedures', error);\n    }\n  }\n\n  /**\n   * Configure query result caching\n   */\n  private async configureCaching(): Promise<void> {\n    // Configure cache with optimized settings\n    queryResultCache.clear(); // Start fresh\n    \n    // Pre-warm cache with common queries\n    const warmupQueries = [\n      {\n        query: 'MATCH (r:Requirement) WHERE r.type = $type RETURN r LIMIT 50',\n        parameters: { type: 'functional' },\n        ttl: 300 // 5 minutes\n      },\n      {\n        query: 'MATCH (ap:ArchitecturePattern) WHERE ap.suitabilityScore > $score RETURN ap',\n        parameters: { score: 8.0 },\n        ttl: 600 // 10 minutes\n      },\n      {\n        query: 'MATCH (r:Requirement)-[m:MAPS_TO]->(a:ArchitectureDecision) WHERE m.confidence > $confidence RETURN count(*)',\n        parameters: { confidence: 0.8 },\n        ttl: 300 // 5 minutes\n      }\n    ];\n\n    await queryResultCache.warmUp(\n      warmupQueries,\n      async (query, params) => await this.neo4jService.executeQuery(query, params)\n    );\n\n    this.report.appliedOptimizations.push('Query Result Caching');\n    logger.info('üíæ Query result caching configured and warmed up');\n  }\n\n  /**\n   * Run comprehensive performance validation\n   */\n  private async runPerformanceValidation(): Promise<void> {\n    const validationResult = await performanceValidator.validatePerformance({\n      maxQueryTime: 100,        // 100ms target\n      maxMemoryUsage: 50 * 1024 * 1024, // 50MB\n      minIndexUsage: 80,        // 80% index usage\n      maxFullScans: 0,          // No full scans\n      minCacheHitRate: 70,      // 70% cache hit rate\n      maxDbHitsPerRow: 50       // 50 db hits per row\n    });\n\n    this.report.performanceImprovements = {\n      validationResult,\n      score: validationResult.overallScore,\n      grade: validationResult.summary.performanceGrade,\n      passed: validationResult.passed\n    };\n\n    this.report.recommendations.push(...validationResult.recommendations);\n    \n    logger.info('‚úÖ Performance validation completed', {\n      score: validationResult.overallScore,\n      grade: validationResult.summary.performanceGrade,\n      passed: validationResult.passed\n    });\n  }\n\n  /**\n   * Collect post-optimization metrics\n   */\n  private async collectPostOptimizationMetrics(): Promise<void> {\n    const { benchmarkResults, performanceBaseline } = await performanceValidator.runPerformanceBenchmarks();\n    \n    this.report.postOptimizationMetrics = {\n      benchmarks: benchmarkResults,\n      baseline: performanceBaseline,\n      cacheStats: queryResultCache.getStats(),\n      timestamp: new Date().toISOString()\n    };\n\n    // Calculate improvements\n    const preTime = this.report.preOptimizationMetrics.baseline?.maxQueryTime || 1000;\n    const postTime = performanceBaseline.maxQueryTime;\n    const improvementPercent = ((preTime - postTime) / preTime) * 100;\n\n    this.report.performanceImprovements.queryTimeImprovement = {\n      before: preTime,\n      after: postTime,\n      improvement: Math.max(0, Math.round(improvementPercent))\n    };\n\n    logger.info('üìà Post-optimization metrics collected', {\n      queryTimeImprovement: `${Math.round(improvementPercent)}%`,\n      cacheHitRate: `${this.report.postOptimizationMetrics.cacheStats.hitRate}%`\n    });\n  }\n\n  /**\n   * Verify success criteria are met\n   */\n  private async verifySuccessCriteria(): Promise<void> {\n    const postMetrics = this.report.postOptimizationMetrics;\n    const validationResult = this.report.performanceImprovements.validationResult;\n\n    // Criterion 1: All queries < 100ms\n    this.report.successCriteria.allQueriesUnder100ms = \n      postMetrics.baseline.maxQueryTime <= 100;\n\n    // Criterion 2: Indexes properly utilized (> 80% usage rate)\n    const indexTests = validationResult.testResults.filter(t => \n      t.testName.includes('Index') && t.passed\n    );\n    this.report.successCriteria.indexesProperlyUtilized = \n      indexTests.length > 0 && indexTests.every(t => t.actualValue >= 80);\n\n    // Criterion 3: Query plans optimized (no critical failures)\n    this.report.successCriteria.queryPlansOptimized = \n      validationResult.summary.criticalFailures === 0;\n\n    // Criterion 4: No full graph scans detected\n    const scanTests = validationResult.testResults.filter(t => \n      t.testName.includes('Full Scan')\n    );\n    this.report.successCriteria.noFullGraphScansDetected = \n      scanTests.length === 0 || scanTests.every(t => t.actualValue === 0);\n\n    // Overall success\n    this.report.overallSuccess = \n      this.report.successCriteria.allQueriesUnder100ms &&\n      this.report.successCriteria.indexesProperlyUtilized &&\n      this.report.successCriteria.queryPlansOptimized &&\n      this.report.successCriteria.noFullGraphScansDetected;\n\n    logger.info('üéØ Success criteria verification:', this.report.successCriteria);\n  }\n\n  /**\n   * Generate comprehensive optimization report\n   */\n  private async generateReport(): Promise<void> {\n    const reportPath = path.join(__dirname, '../reports/neo4j-optimization-report.json');\n    const reportDir = path.dirname(reportPath);\n    \n    // Ensure reports directory exists\n    if (!fs.existsSync(reportDir)) {\n      fs.mkdirSync(reportDir, { recursive: true });\n    }\n\n    // Save detailed JSON report\n    fs.writeFileSync(reportPath, JSON.stringify(this.report, null, 2));\n\n    // Generate markdown summary\n    const markdownReport = this.generateMarkdownReport();\n    const markdownPath = path.join(__dirname, '../reports/neo4j-optimization-summary.md');\n    fs.writeFileSync(markdownPath, markdownReport);\n\n    logger.info('üìã Optimization report generated', {\n      jsonReport: reportPath,\n      markdownSummary: markdownPath\n    });\n  }\n\n  /**\n   * Generate markdown summary report\n   */\n  private generateMarkdownReport(): string {\n    const improvements = this.report.performanceImprovements.queryTimeImprovement;\n    const cacheStats = this.report.postOptimizationMetrics.cacheStats;\n    const successCount = Object.values(this.report.successCriteria).filter(Boolean).length;\n    \n    return `# LANKA Neo4j Optimization Report - Phase 2.3\n\n**Timestamp**: ${this.report.timestamp}\n**Overall Success**: ${this.report.overallSuccess ? '‚úÖ PASSED' : '‚ùå FAILED'}\n\n## Executive Summary\n\n${this.report.overallSuccess ? \n  'üéâ **SUCCESS**: All optimization objectives achieved!' :\n  '‚ö†Ô∏è  **PARTIAL SUCCESS**: Some optimization objectives require additional work.'}\n\n## Performance Improvements\n\n- **Query Performance**: ${improvements ? improvements.improvement : 0}% improvement\n- **Cache Hit Rate**: ${cacheStats?.hitRate || 0}%\n- **Applied Optimizations**: ${this.report.appliedOptimizations.length}\n- **Overall Score**: ${this.report.performanceImprovements.score || 0}/100\n- **Performance Grade**: ${this.report.performanceImprovements.grade || 'N/A'}\n\n## Success Criteria Status\n\n| Criterion | Status | Details |\n|-----------|--------|----------|\n| All queries < 100ms | ${this.report.successCriteria.allQueriesUnder100ms ? '‚úÖ' : '‚ùå'} | Target: <100ms, Actual: ${this.report.postOptimizationMetrics.baseline?.maxQueryTime || 'N/A'}ms |\n| Indexes properly utilized | ${this.report.successCriteria.indexesProperlyUtilized ? '‚úÖ' : '‚ùå'} | Target: >80% usage |\n| Query plans optimized | ${this.report.successCriteria.queryPlansOptimized ? '‚úÖ' : '‚ùå'} | No critical plan issues |\n| No full graph scans | ${this.report.successCriteria.noFullGraphScansDetected ? '‚úÖ' : '‚ùå'} | Zero full scans detected |\n\n**Success Rate**: ${successCount}/4 criteria met\n\n## Applied Optimizations\n\n${this.report.appliedOptimizations.map(opt => `- ${opt}`).join('\\n')}\n\n## Key Metrics\n\n### Before Optimization\n- Average Query Time: ${this.report.preOptimizationMetrics.baseline?.maxQueryTime || 'N/A'}ms\n\n### After Optimization  \n- Average Query Time: ${this.report.postOptimizationMetrics.baseline?.maxQueryTime || 'N/A'}ms\n- Cache Hit Rate: ${cacheStats?.hitRate || 0}%\n- Total Cache Entries: ${cacheStats?.cacheSize || 0}\n\n## Recommendations\n\n${this.report.recommendations.map(rec => `- ${rec}`).join('\\n')}\n\n## Next Steps\n\n${this.report.overallSuccess ? `\n‚úÖ **Phase 2.3 Complete**: All Neo4j optimization objectives achieved.\n\n**Recommended Actions**:\n- Monitor performance continuously\n- Implement automated performance regression testing\n- Schedule periodic index maintenance\n- Continue cache optimization based on usage patterns\n` : `\n‚ö†Ô∏è  **Additional Work Required**:\n\n${this.report.recommendations.filter(r => r.includes('optimize') || r.includes('fix') || r.includes('improve')).map(r => `- ${r}`).join('\\n')}\n\n**Priority Actions**:\n1. Address failed success criteria\n2. Implement additional query optimizations\n3. Re-run validation after improvements\n`}\n\n---\n*Generated by LANKA Performance Optimization System*\n`;\n  }\n}\n\n// Main execution\nif (require.main === module) {\n  const runner = new Neo4jOptimizationRunner();\n  \n  runner.runOptimization()\n    .then((report) => {\n      console.log('\\nüéâ LANKA Neo4j Optimization Completed!');\n      console.log(`üìä Overall Success: ${report.overallSuccess ? 'YES ‚úÖ' : 'NO ‚ùå'}`);\n      console.log(`üöÄ Performance Score: ${report.performanceImprovements.score || 0}/100`);\n      console.log(`üìà Performance Grade: ${report.performanceImprovements.grade || 'N/A'}`);\n      console.log(`\\nüìã Full report available in: reports/neo4j-optimization-report.json`);\n      \n      if (!report.overallSuccess) {\n        console.log('\\n‚ö†Ô∏è  Some criteria not met. Check recommendations in the report.');\n        process.exit(1);\n      }\n      \n      process.exit(0);\n    })\n    .catch((error) => {\n      console.error('\\n‚ùå Optimization failed:', error.message);\n      process.exit(1);\n    });\n}\n\nexport { Neo4jOptimizationRunner, type OptimizationReport };